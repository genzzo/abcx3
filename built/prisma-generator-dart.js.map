{
  "version": 3,
  "sources": ["../libs/prisma-generator-dart/package.json", "../libs/prisma-generator-dart/src/generator.ts", "../libs/prisma-generator-dart/src/constants.ts", "../libs/prisma-generator-dart/src/stubs/dart.stub.ts", "../libs/shared/src/writeFileSafely.ts", "../libs/shared/src/stringFns.ts", "../libs/shared/src/prisma.helper.ts", "../libs/prisma-generator-dart/src/generators/dart.generator.ts", "../libs/prisma-generator-dart/src/generators/enum.generators.ts"],
  "sourcesContent": ["{\n  \"name\": \"@prisma-tools/prisma-generator-dart\",\n  \"description\": \"Generate Dart class files with uding to- and fromJson methods from a Prisma schema\",\n  \"version\": \"1.0.0\",\n  \"main\": \"src/generator.js\",\n  \"bin\": {\n    \"prisma-generator-dart\": \"src/generator.js\"\n  },\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n", "import { DMMF, generatorHandler, GeneratorOptions } from '@prisma/generator-helper';\nimport { exec } from 'child_process';\nimport path from 'path';\nimport { GENERATOR_NAME } from './constants';\nimport { DartGenerator } from './generators/dart.generator';\nimport { generateDartEnum } from './generators/enum.generators';\nimport { GeneratorSettings } from './settings.interface';\n\nimport { StringFns } from '../../shared/src/stringFns';\nimport { outputToConsole, writeFileSafely } from '../../shared/src/writeFileSafely';\n\n// import {w} from '@prisma-tools/shared';\n\nconst { version } = require('../package.json');\n\nconst defaultOptions: GeneratorSettings = {\n    dryRun: 'false',\n    schemaPath: '',\n    EnumPath: 'enums',\n    FormatWithDart: 'true',\n    makeAllPropsOptional: 'true'\n};\n\ngeneratorHandler({\n  onManifest() {\n    console.log(`${GENERATOR_NAME}:Registered`);\n    return {\n      version,\n      defaultOutput: '../generated',\n      prettyName: GENERATOR_NAME,\n    }\n  },\n  onGenerate: async (options: GeneratorOptions) => {\n    const configOverwrites = {\n        schemaPath: options.schemaPath,\n    };\n\n    const settings: GeneratorSettings = {\n        ...defaultOptions,\n        ...options.generator.config,\n        ...configOverwrites,\n    };\n\n    console.log('hello from dart gen');\n    const mainGenerator = new MainGenerator(options, settings);\n    await mainGenerator.generateFiles();\n  }\n})\n\nclass MainGenerator {\n\n    private dartFiles: string[] = [];\n\n    writeFile: (path: string, content: string) => void;\n    outputPath: string;\n\n    constructor(private options: GeneratorOptions, private settings: GeneratorSettings) {\n        this.writeFile = settings.dryRun === 'false' ? writeFileSafely : outputToConsole;\n        this.outputPath = this.options.generator.output?.value as string;\n    }\n\n    async generateFiles(options = this.options, settings = this.settings) {\n\n        for (const model of options.dmmf.datamodel.models) {        \n            console.log(`Processing Model ${model.name}`); \n            await this.generateDartModelFile(model);\n        }\n\n        for (const tEnum of options.dmmf.datamodel.enums) {\n            console.log(`Processing Enum ${tEnum.name}`);\n            await this.generateDartEnumFile(tEnum);\n        }\n        await this.createDartLibraryFile();\n        if (this.settings.FormatWithDart === 'true') {\n            const outputPath = options.generator.output?.value;\n            exec(`dart format \"${outputPath}\"`, (error, stdout, stderr) => {\n                if (error) {\n                    console.log(`error: ${error.message}`);\n                    return;\n                }\n                if (stderr) {\n                    console.log(`stderr: ${stderr}`);\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);\n            });\n        }\n    }\n\n    async generateDartEnumFile(tEnum: DMMF.DatamodelEnum) {\n        let content = generateDartEnum(tEnum);\n        const fileName = `${StringFns.decapitalizeFileName(tEnum.name, 'dart')}`;\n        const filePath = path.join(this.outputPath, fileName);\n        console.log(` > Generating enum for Model ${tEnum.name}`);\n        await this.writeFile(filePath, content);\n        this.dartFiles.push(fileName);\n    }\n\n    async createDartLibraryFile() {\n        let content = this.dartFiles.reduce((acc, val) => acc + `export '${val}';\\n`, \"\");\n        const filePath = path.join(\n            this.outputPath,\n            `models_library.dart`\n        );\n        await this.writeFile(filePath, content);\n    }\n\n    async generateDartModelFile(model: DMMF.Model) {\n        const dartGenerator = new DartGenerator(this.settings, model);\n        const dartContent = dartGenerator.generateContent();\n        const fileName = `${StringFns.decapitalizeFileName(model.name, 'dart')}`;\n        const filePath = path.join(\n            this.outputPath,\n            fileName,\n        );\n        this.dartFiles.push(fileName);\n        console.log(` > Generating Dart class for Model ${model.name}`);\n        await this.writeFile(filePath, dartContent);\n    }\n}\n\n\n", "export const GENERATOR_NAME = 'prisma-generator-dart';\n", "export const dartBaseClassStub = `/*\r\n-----------------------------------------------------\r\nTHIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)\r\n-----------------------------------------------------\r\n*/\r\n\r\n#{Imports}\r\n\r\nclass #{ClassName} #{ParentClass} {\r\n    #{Properties}\r\n    \r\n      #{ClassName}({#{ConstructorArgs}});\r\n\r\n      factory #{ClassName}.fromJson(Map<String, dynamic> json) =>\r\n      #{ClassName}(\r\n        #{fromJsonArgs}\r\n      );\r\n\r\n      Map<String, dynamic> toJson() => ({\r\n        #{toJsonKeyValues}\r\n      });\r\n      }\r\n    `;\r\n\r\nexport const dartFromJsonArg = `#{PropName}: json['#{PropName}'] as #{Type}#{Nullable}`;\r\n\r\nexport const dartFromJsonListArg = `#{PropName}: (json['#{PropName}'] as List<#{Type}>#{Nullable})#{Nullable}\\n.map((item) => #{Type}.fromJson(item as Map<String, dynamic>)).toList()`;\r\nexport const toJsonPropertyStub = `'#{PropName}': #{PropName}`;\r\nexport const toJsonListPropertyStub = `'#{PropName}': #{PropName}#{Nullable}.map((item) => item.toJson()).toList()`;\r\n//export const toJsonObjectPropertyStub = `'#{PropName}': #{PropName}`;\r\n\r\n\r\nexport const dartConstructorArgument = `#{Required} this.#{PropName}`;\r\nexport const dartConstructorArgumentWithDefaultValue = `#{Required} this.#{PropName} = #{DefaultValue}`;\r\n\r\n\r\nexport const dartPropertyStub = `#{Type}#{Nullable} #{PropName};`;\r\n\r\nexport const dartPropertyStubWithDefaultValue = `#{Type}#{Nullable} #{PropName} = #{DefaultValue};`;\r\n\r\n", "import * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { format } from 'prettier';\r\n\r\n\r\nexport async function writeFileSafely(filePath: string, content: string) {\r\n    if (filePath.match(/.ts$/)) {\r\n        content = format(content, {useTabs: true, tabWidth: 4, parser: 'typescript'});\r\n    }\r\n    fs.mkdirSync(path.dirname(filePath), {\r\n        recursive: true,\r\n    });\r\n    fs.writeFileSync(filePath, content);\r\n\r\n}\r\n\r\nexport async function outputToConsole(filePath: string, content: string) {\r\n    if (filePath.match(/.ts$/)) {\r\n        content = await format(content, {parser: 'typescript'});\r\n    }\r\n    console.log(content);\r\n}", "\r\nexport class StringFns {\r\n\r\n    static decapitalizeFileName (name: string, fileType: string) {\r\n        return this.decapitalize(name) + '.' + fileType;\r\n    }\r\n\r\n    static decapitalize(str: string): string {\r\n        return this.transformFirstCharCase(str, 'toLowerCase');\r\n    }\r\n\r\n    static capitalize (str: string): string | null {\r\n        return this.transformFirstCharCase(str, 'toUpperCase');\r\n    }\r\n\r\n    static transformFirstCharCase(str: string, fnName: 'toUpperCase' | 'toLowerCase'): string {\r\n        if (str == null || str.length === 0) {\r\n            return '';\r\n        } else {\r\n            const firstChar = (fnName === 'toLowerCase') ? str[0].toLowerCase() : str[0].toUpperCase();\r\n            return firstChar + str.substring(1);\r\n        }\r\n    }\r\n\r\n}", "import { DMMF } from '@prisma/generator-helper';\r\nimport { StringFns } from './stringFns';\r\n\r\nexport interface FieldNameAndType {\r\n    name: string;\r\n    type: string;\r\n}\r\n\r\nexport interface PrismaCommentDirective {\r\n    name: string;\r\n    argument?: string;\r\n} \r\n\r\n\r\nexport class PrismaHelper {\r\n    static instance: PrismaHelper;\r\n\r\n    static getInstance() {\r\n        if (PrismaHelper.instance) {\r\n            return PrismaHelper.instance;\r\n        }\r\n        PrismaHelper.instance = new PrismaHelper();\r\n        return PrismaHelper.instance;\r\n    }\r\n\r\n    public getUniqueInputPropertyName(model: DMMF.Model): string | null {\r\n\r\n        const primaryKey = model.primaryKey;\r\n        if (primaryKey?.fields) {\r\n            let compoundName = primaryKey.fields.reduce((acc: string, fieldName: string) => acc + '_' + fieldName, '');\r\n            compoundName = compoundName.substring(1);\r\n            return compoundName;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public getUniqueInputType(model: DMMF.Model): string | null {\r\n\r\n        const primaryKey = model.primaryKey;\r\n        if (primaryKey?.fields) {\r\n            let compoundName = primaryKey.fields.reduce((acc: string, fieldName: string) => acc + StringFns.capitalize(fieldName), '');\r\n            return compoundName;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public parseDocumentation(field: DMMF.Field | DMMF.Model): PrismaCommentDirective[] {\r\n        let documentation = field.documentation || '';\r\n\r\n        documentation = documentation.replace(/(\\r\\n|\\n|\\r)/gm, ' ');\r\n\r\n        const comments = documentation.split(' ');\r\n\r\n        const result: PrismaCommentDirective[] = [];\r\n\r\n        for (const comment of comments) {\r\n            const argIndex = comment.indexOf('(');\r\n            const argument = comment.substring(\r\n                argIndex + 1,\r\n                comment.lastIndexOf(')'),\r\n            );\r\n\r\n            const directiveName = comment.substring(0, argIndex);\r\n\r\n            const decorator = {name: directiveName, argument: argument} satisfies PrismaCommentDirective;\r\n\r\n            result.push(decorator);\r\n        }\r\n        return result;\r\n    }\r\n   \r\n}\r\n", "import { DMMF } from '@prisma/generator-helper';\r\n// import { PrismaHelper, StringFns } from 'libs/shared/src';\r\nimport { GeneratorSettings } from '../settings.interface';\r\nimport {\r\n    dartBaseClassStub,\r\n    dartConstructorArgument,\r\n    dartConstructorArgumentWithDefaultValue,\r\n    dartPropertyStub,\r\n    dartFromJsonArg,\r\n    dartFromJsonListArg,\r\n    toJsonPropertyStub,\r\n    toJsonListPropertyStub\r\n} from '../stubs/dart.stub';\r\nimport { PrismaHelper, StringFns } from '../../../shared/src';\r\n\r\nexport const dartTypeMap = {\r\n    BigInt: 'BigInt',\r\n    Boolean: 'bool',\r\n    Bytes: 'ByteBuffer',\r\n    DateTime: 'DateTime',\r\n    Decimal: 'double',\r\n    Float: 'double',\r\n    Int: 'int',\r\n    Json: 'Map<String, dynamic>',\r\n    String: 'String'\r\n}\r\n\r\ntype DartTypeMapKey = keyof typeof dartTypeMap;\r\n\r\nexport class DartGenerator {\r\n    private importedPackages: string[] = [];\r\n    private omitFields: string[] = [];\r\n    private prismaHelper: PrismaHelper;\r\n\r\n    constructor(private config: GeneratorSettings, private model: DMMF.Model) {\r\n        this.prismaHelper = PrismaHelper.getInstance();\r\n    }\r\n\r\n    generateContent() {\r\n        let content = this.generateBaseInput();\r\n\r\n        content = content.replace(/#{Imports}/g, this.generateImportStatements());\r\n        return content;\r\n    }\r\n\r\n    private generateBaseInput() {\r\n        let content = dartBaseClassStub;\r\n\r\n        const className = this.model.name;\r\n        content = content.replace(/#{ClassName}/g, className);\r\n\r\n        // handle the parent class (extends)\r\n\r\n        const parentClassInjection = '';\r\n        content = content.replace(/#{ParentClass}/g, parentClassInjection);\r\n\r\n        let constructorArgs: string[] = [];\r\n        let properties: string[] = [];\r\n        let fromJsonArgs: string[] = [];\r\n        let toJsonKeyVals: string[] = [];\r\n\r\n        for (const field of this.model.fields) {\r\n            const commentDirectives = this.prismaHelper.parseDocumentation(field);\r\n            if (commentDirectives.some(directive => directive.name === '@ptools_omit')) {\r\n                continue;\r\n            }\r\n            properties.push(this.generatePropertyContent(field));\r\n            constructorArgs.push(this.generateConstructorArg(field));\r\n            fromJsonArgs.push(this.generateFromJsonArgument(field));\r\n            toJsonKeyVals.push(this.generateToJsonKeyVal(field));\r\n        }\r\n        const propertiesContent = properties.join('\\n\\t');\r\n        const constructorContent = constructorArgs.join(',\\n\\t');\r\n        const fromJsonContent = fromJsonArgs.join(',\\n\\t');\r\n        const toJsonContent = toJsonKeyVals.join(',\\n\\t');\r\n        content = content.replace(/#{fromJsonArgs}/g, fromJsonContent);\r\n        content = content.replace(/#{toJsonKeyValues}/g, toJsonContent);\r\n\r\n        content = content.replace(/#{Properties}/g, propertiesContent);\r\n        content = content.replace(/#{ConstructorArgs}/g, constructorContent);\r\n\r\n        return content;\r\n    }\r\n\r\n\r\n   /*  const documentation = field.documentation;\r\n        let customDecoratorsContent = '';\r\n        if (documentation) {\r\n            // we need to process this properly\r\n            const customDecorators = this.parseDocumentation(field);\r\n\r\n            for (const customDecorator of customDecorators) {\r\n                // check, if the current field has an @Omit() decorator, so we skip everything\r\n                if (customDecorator.name === 'Omit') {\r\n                    this.omitFields.push(field.name);\r\n                    continue;\r\n                }\r\n\r\n                // if the element has an @Relation() decorator\r\n                if (customDecorator.name === 'Relation') {\r\n                    // for now, we do nothing\r\n                    this.omitFields.push(field.name);\r\n                    continue;\r\n                }\r\n\r\n                // if the element has an @RelationId() decorator\r\n                if (customDecorator.name === 'RelationId') {\r\n                    // for now, we do nothing\r\n                    this.omitFields.push(field.name);\r\n                    continue;\r\n                }\r\n\r\n                customDecoratorsContent =\r\n                    customDecoratorsContent + customDecorator.generateContent();\r\n                this.addDecoratorToImport(customDecorator);\r\n            }\r\n        } */\r\n\r\n    generateConstructorArg(field: DMMF.Field): string {\r\n        let content = '';\r\n        if (field.hasDefaultValue && !(field.default instanceof Object)) {\r\n            content = dartConstructorArgumentWithDefaultValue;\r\n            let defValue = field.default!;\r\n            let valueStr: string;\r\n            if (field.kind === 'enum') {\r\n                valueStr = `${field.type}.${defValue}`;\r\n            } else {\r\n                valueStr = typeof defValue === 'string' ? `\"${defValue}\"` : defValue.toString();\r\n            }\r\n            content = content.replace(/#{DefaultValue}/g, valueStr);\r\n            content = content.replace(/#{Required}/g, '');\r\n        } else {\r\n            content = dartConstructorArgument;\r\n            content = content.replace(/#{Required}/g, field.isRequired ? 'required' : '');\r\n        }\r\n        content = content.replace(/#{PropName}/g, field.name);\r\n        return content;\r\n    }\r\n\r\n    printDefaultValue(field: DMMF.Field): string | null {\r\n        if (field.hasDefaultValue && !(field.default instanceof Object)) {\r\n            let defValue = field.default!;\r\n            let valueStr: string;\r\n            if (field.kind === 'enum') {\r\n                return `${field.type}.${defValue}`;\r\n            } else {\r\n                return typeof defValue === 'string' ? `\"${defValue}\"` : defValue.toString();\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    generateFromJsonArgument(field: DMMF.Field) {\r\n        let content = (field.isList) ? dartFromJsonListArg : dartFromJsonArg;\r\n        content = this.replacePropName(content, field);\r\n        content = this.replaceNullable(content, field);\r\n        content = this.replaceType(content, field);\r\n        return content;\r\n    }\r\n\r\n    generateToJsonKeyVal(field: DMMF.Field) {\r\n        let content = (field.isList) ? toJsonListPropertyStub : toJsonPropertyStub;\r\n        content = this.replacePropName(content, field);\r\n        content = this.replaceNullable(content, field);\r\n        return content;\r\n    }\r\n\r\n    generatePropertyContent(field: DMMF.Field) {\r\n        let content = dartPropertyStub;\r\n\r\n        content = content.replace(/#{PropName}/g, field.name);\r\n        let dartType = this.getDartType(field);\r\n        let printedType = (field.isList) ? `List<${dartType}>` : dartType;\r\n        content = content.replace(/#{Type}/g, printedType);\r\n        content = this.replaceNullable(content, field);\r\n        \r\n        return content;\r\n    }\r\n\r\n    getDartType = (field: DMMF.Field) => dartTypeMap[field.type as DartTypeMapKey] || field.type;\r\n    isProprietaryType = (type: string) => dartTypeMap[type as DartTypeMapKey] ==  null;\r\n    \r\n\r\n    replaceNullable = (content: string, field: DMMF.Field) => content.replace(/#{Nullable}/g, field.isRequired ? '' : '?');\r\n    replacePropName = (content: string, field: DMMF.Field) => content.replace(/#{PropName}/g, field.name);\r\n    replaceType = (content: string, field: DMMF.Field) => content.replace(/#{Type}/g, this.getDartType(field));\r\n\r\n    private generateImportStatements(): string {\r\n        let result = '';\r\n        const checkedTypes: string[] = [];\r\n\r\n        this.model.fields.forEach(({type}) => {\r\n            if (!checkedTypes.includes(type)) {\r\n                checkedTypes.push(type);\r\n                if (this.isProprietaryType(type)) {\r\n                    result += `import '${StringFns.decapitalizeFileName(type, 'dart')}';\\n`;\r\n                }\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n}\r\n\r\n", "import { DMMF } from '@prisma/generator-helper'\r\n\r\nexport const generateEnum = ({ name, values }: DMMF.DatamodelEnum) => {\r\n  const enumValues = values.map(({ name }) => `${name}=\"${name}\"`).join(',\\n');\r\n\r\n  return `enum ${name} { \\n${enumValues}\\n }`;\r\n}\r\n\r\nexport const generateDartEnum = ({ name, values }: DMMF.DatamodelEnum) => {\r\n    const enumValues = values.map(({ name }) => name).join(',\\n\\t');\r\n  \r\n    return `enum ${name} {\\n\\t${enumValues}\\n}`\r\n  }"],
  "mappings": "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",
  "names": ["require_package", "__commonJSMin", "exports", "module", "import_generator_helper", "import_child_process", "import_path", "GENERATOR_NAME", "dartBaseClassStub", "dartFromJsonArg", "dartFromJsonListArg", "toJsonPropertyStub", "toJsonListPropertyStub", "dartConstructorArgument", "dartConstructorArgumentWithDefaultValue", "dartPropertyStub", "fs", "path", "import_prettier", "writeFileSafely", "filePath", "content", "outputToConsole", "StringFns", "name", "fileType", "str", "fnName", "_PrismaHelper", "model", "primaryKey", "compoundName", "acc", "fieldName", "StringFns", "field", "documentation", "comments", "result", "comment", "argIndex", "argument", "decorator", "PrismaHelper", "__publicField", "dartTypeMap", "DartGenerator", "config", "model", "PrismaHelper", "content", "dartBaseClassStub", "className", "parentClassInjection", "constructorArgs", "properties", "fromJsonArgs", "toJsonKeyVals", "field", "directive", "propertiesContent", "constructorContent", "fromJsonContent", "toJsonContent", "dartConstructorArgumentWithDefaultValue", "defValue", "valueStr", "dartConstructorArgument", "dartFromJsonListArg", "dartFromJsonArg", "toJsonListPropertyStub", "toJsonPropertyStub", "dartPropertyStub", "dartType", "printedType", "type", "result", "checkedTypes", "StringFns", "generateDartEnum", "name", "values", "enumValues", "version", "defaultOptions", "GENERATOR_NAME", "options", "configOverwrites", "settings", "MainGenerator", "writeFileSafely", "outputToConsole", "model", "tEnum", "outputPath", "error", "stdout", "stderr", "content", "generateDartEnum", "fileName", "StringFns", "filePath", "path", "acc", "val", "dartContent", "DartGenerator"]
}

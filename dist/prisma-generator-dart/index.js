"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// libs/prisma-generator-dart/package.json
var require_package = __commonJS({
  "libs/prisma-generator-dart/package.json"(exports, module2) {
    module2.exports = {
      name: "@abcx3/prisma-generator-dart",
      description: "Generate Dart class files with to- and fromJson methods from a Prisma schema",
      version: "1.0.0",
      main: "src/generator.js",
      bin: {
        "prisma-generator-dart": "src/generator.js"
      },
      scripts: {},
      keywords: [],
      author: "",
      license: "ISC"
    };
  }
});

// libs/prisma-generator-dart/src/generator.ts
var import_generator_helper = require("@prisma/generator-helper");
var import_child_process = require("child_process");
var import_path = __toESM(require("path"));

// libs/prisma-generator-dart/src/constants.ts
var GENERATOR_NAME = "prisma-generator-dart";

// libs/prisma-generator-dart/src/stubs/dart.stub.ts
var dartBaseClassStub = `
#{AutoGeneratedWarningText}

#{Imports}

class #{ClassName} #{ParentClass}#{ImplementedClass}{
    #{Properties}
    
      #{ClassName}({#{ConstructorArgs}});

      factory #{ClassName}.fromJson(Map<String, dynamic> json) =>
      #{ClassName}(
        #{fromJsonArgs}
      );

      #{OverrideAnnotation}
      Map<String, dynamic> toJson() => ({
        #{toJsonKeyValues}
      });

        #{OverrideAnnotation}
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is #{ClassName} &&
                runtimeType == other.runtimeType &&
                #{equalsKeyValues};

        #{OverrideAnnotation}
        int get hashCode => #{hashCodeKeyValues};
      }
    `;
var dartFromJsonArg = `#{PropName}: json['#{PropName}'] as #{Type}#{Nullable}`;
var dartFromJsonRefArg = `#{PropName}: json['#{PropName}'] != null ? #{Type}.fromJson(json['#{PropName}'] as Map<String, dynamic>) : null`;
var dartFromJsonScalarIntListArg = `#{PropName}: json['#{PropName}'] != null ? (json['#{PropName}'] as List<dynamic>).map((e) => int.parse(e.toString())).toList() : null`;
var dartFromJsonScalarStringListArg = `#{PropName}: json['#{PropName}'] != null ? (json['#{PropName}'] as List<dynamic>).map((e) => e.toString()).toList() : null`;
var dartFromJsonModelListArg = `#{PropName}: json['#{PropName}'] != null ? createModels<#{Type}>(json['#{PropName}'], #{Type}.fromJson) : null`;
var dartFromJsonEnumArg = `#{PropName}: #{Type}.values.byName(json['#{PropName}'])`;
var dartFromJsonEnumListArg = `#{PropName}: (json['#{PropName}']).map((item) => #{Type}.values.byName(json[item])).toList())`;
var dartFromJsonDateTimeArg = `#{PropName}: json['#{PropName}'] != null ? DateTime.parse(json['#{PropName}']) : null`;
var toJsonPropertyStub = `'#{PropName}': #{PropName}`;
var toJsonListPropertyStub = `'#{PropName}': #{PropName}#{Nullable}.map((item) => item.toJson()).toList()`;
var dartEqualsKeyValue = `#{PropName} == other.#{PropName}`;
var dartHashCodeKeyValue = `#{PropName}.hashCode`;
var dartConstructorArgument = `#{Required} this.#{PropName}`;
var dartConstructorArgumentWithDefaultValue = `#{Required} this.#{PropName} = #{DefaultValue}`;
var dartPropertyStub = `#{Type}#{Nullable} #{PropName};`;
var dartModelBaseClassStub = `abstract class ModelBase {
    abstract int? id;
    Map<String, dynamic> toJson();
  }
  
  typedef JsonModelFactory<T> = T Function(Map<String, dynamic> json);

  List<T> createModels<T>(json, JsonModelFactory<T> jsonFactory) {
    List<T> instances = [];
    for (final item in json) {
      instances.add(jsonFactory(item as Map<String, dynamic>));
    }
    return instances;
  }
  `;

// libs/shared/src/writeFileSafely.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
async function writeFileSafely(filePath, content) {
  fs.mkdirSync(path.dirname(filePath), {
    recursive: true
  });
  fs.writeFileSync(filePath, content);
}
async function outputToConsole(filePath, content) {
  console.log(content);
}

// libs/shared/src/stringFns.ts
var StringFns = class {
  static decapitalizeFileName(name, fileType) {
    return this.decapitalize(name) + "." + fileType;
  }
  static decapitalize(str) {
    return this.transformFirstCharCase(str, "toLowerCase");
  }
  static capitalize(str) {
    return this.transformFirstCharCase(str, "toUpperCase");
  }
  static transformFirstCharCase(str, fnName) {
    if (str == null || str.length === 0) {
      return "";
    } else {
      const firstChar = fnName === "toLowerCase" ? str[0].toLowerCase() : str[0].toUpperCase();
      return firstChar + str.substring(1);
    }
  }
  static snakeCase(str) {
    return str[0].toLowerCase() + str.substring(1).replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
  static snakeToCamelCase(str) {
    return str[0].toLowerCase() + str.substring(1).replace(/_[A-Z]/g, (letter) => `_${letter[1].toLowerCase()}`);
  }
};

// libs/shared/src/prisma.helper.ts
var PrismaTypeScriptTypeMap = {
  BigInt: "BigInt",
  Boolean: "boolean",
  Bytes: "Buffer",
  DateTime: "Date",
  Decimal: "number",
  Float: "number",
  Int: "number",
  Json: "object",
  String: "string"
};
var _PrismaHelper = class {
  static getInstance() {
    if (_PrismaHelper.instance) {
      return _PrismaHelper.instance;
    }
    _PrismaHelper.instance = new _PrismaHelper();
    return _PrismaHelper.instance;
  }
  convertToTypescriptType(field) {
    let tsType = PrismaTypeScriptTypeMap[field.type];
    return !tsType ? field.type : tsType;
  }
  getIdFieldNameAndType(model) {
    const idField = model.fields.find((field) => field.isId === true);
    if (idField) {
      return this.getFieldNameAndType(idField);
    } else {
      return null;
    }
  }
  getFieldNameAndType(field) {
    return {
      name: field.name,
      type: this.convertToTypescriptType(field)
    };
  }
  modelContainsObjectReference = (model) => model.fields.some((field) => field.kind === "object");
  getReferenceFields = (model) => model.fields.filter((field) => field.kind === "object");
  getUniqueReferenceFields = (model) => model.fields.reduce((acc, field) => {
    if (field.kind === "object" && !acc.some((f) => f.type === field.type))
      acc.push(field);
    return acc;
  }, []);
  //(field => field.kind === 'object');
  getUniqueInputPropertyName(model) {
    const primaryKey = model.primaryKey;
    if (primaryKey?.fields) {
      let compoundName = primaryKey.fields.reduce((acc, fieldName) => acc + "_" + fieldName, "");
      compoundName = compoundName.substring(1);
      return compoundName;
    } else {
      return null;
    }
  }
  getUniqueInputType(model) {
    const primaryKey = model.primaryKey;
    if (primaryKey?.fields) {
      let compoundName = primaryKey.fields.reduce((acc, fieldName) => acc + StringFns.capitalize(fieldName), "");
      return compoundName;
    } else {
      return null;
    }
  }
  parseDocumentation(field) {
    let documentation = field.documentation || "";
    documentation = documentation.replace(/(\r\n|\n|\r)/gm, " ");
    const comments = documentation.split(" ");
    const result = [];
    for (const comment of comments) {
      const argIndex = comment.indexOf("(");
      const argument = comment.substring(
        argIndex + 1,
        comment.lastIndexOf(")")
      );
      const directiveName = comment.substring(0, argIndex);
      const decorator = { name: directiveName, argument };
      result.push(decorator);
    }
    return result;
  }
};
var PrismaHelper = _PrismaHelper;
__publicField(PrismaHelper, "instance");

// libs/shared/src/utils.ts
function convertBooleanStrings(obj) {
  const result = {};
  for (const key in obj) {
    result[key] = convertBooleanString(obj[key]);
  }
  return result;
}
function convertBooleanString(value) {
  switch (value.toLowerCase()) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      return value;
  }
}

// libs/prisma-generator-dart/src/generators/dart.generator.ts
var dartTypeMap = {
  BigInt: "BigInt",
  Boolean: "bool",
  Bytes: "ByteBuffer",
  DateTime: "DateTime",
  Decimal: "double",
  Float: "double",
  Int: "int",
  Json: "Map<String, dynamic>",
  String: "String"
};
var DartGenerator = class {
  constructor(settings, model) {
    this.settings = settings;
    this.model = model;
    this.prismaHelper = PrismaHelper.getInstance();
  }
  importedPackages = [];
  omitFields = [];
  prismaHelper;
  generateContent() {
    let content = this.generateBaseInput();
    content = content.replace(/#{Imports}/g, this.generateImportStatements());
    return content;
  }
  generateBaseInput() {
    let content = dartBaseClassStub;
    content = content.replace(/#{AutoGeneratedWarningText}/g, this.settings.AutoGeneratedWarningText);
    const className = this.model.name;
    content = content.replace(/#{ClassName}/g, className);
    const parentClassInjection = "";
    content = content.replace(/#{ParentClass}/g, parentClassInjection);
    if (this.settings.ModelsImplementBaseClass) {
      content = content.replace(/#{ImplementedClass}/g, "implements ModelBase ");
      content = content.replace(/#{OverrideAnnotation}/g, "@override");
    } else {
      content = content.replace(/#{ImplementedClass}/g, "");
      content = content.replace(/#{OverrideAnnotation}/g, "");
    }
    let constructorArgs = [];
    let properties = [];
    let fromJsonArgs = [];
    let toJsonKeyVals = [];
    let equalsKeyVals = [];
    let hashCodeKeyVals = [];
    for (const field of this.model.fields) {
      const commentDirectives = this.prismaHelper.parseDocumentation(field);
      if (commentDirectives.some((directive) => directive.name === "@abcx3_omit")) {
        continue;
      }
      properties.push(this.generatePropertyContent(field));
      constructorArgs.push(this.generateConstructorArg(field));
      fromJsonArgs.push(this.generateFromJsonArgument(field));
      toJsonKeyVals.push(this.generateToJsonKeyVal(field));
      equalsKeyVals.push(this.generateEqualsKeyValue(field));
      hashCodeKeyVals.push(this.generateHashCodeValue(field));
    }
    const propertiesContent = properties.join("\n	");
    const constructorContent = constructorArgs.join(",\n	");
    const fromJsonContent = fromJsonArgs.join(",\n	");
    const toJsonContent = toJsonKeyVals.join(",\n	");
    const equalsContent = equalsKeyVals.join(" &&\n		");
    const hashCodeContent = hashCodeKeyVals.join(" ^\n		");
    content = content.replace(/#{fromJsonArgs}/g, fromJsonContent);
    content = content.replace(/#{toJsonKeyValues}/g, toJsonContent);
    content = content.replace(/#{Properties}/g, propertiesContent);
    content = content.replace(/#{ConstructorArgs}/g, constructorContent);
    content = content.replace(/#{equalsKeyValues}/g, equalsContent);
    content = content.replace(/#{hashCodeKeyValues}/g, hashCodeContent);
    return content;
  }
  generateEqualsKeyValue(field) {
    let content = dartEqualsKeyValue;
    content = content.replace(/#{PropName}/g, field.name);
    return content;
  }
  generateHashCodeValue(field) {
    let content = dartHashCodeKeyValue;
    content = content.replace(/#{PropName}/g, field.name);
    return content;
  }
  generateConstructorArg(field) {
    let content = "";
    if (field.hasDefaultValue && !(field.default instanceof Object)) {
      content = dartConstructorArgumentWithDefaultValue;
      let defValue = field.default;
      let valueStr;
      if (field.kind === "enum") {
        valueStr = `${field.type}.${defValue}`;
      } else {
        valueStr = typeof defValue === "string" ? `"${defValue}"` : defValue.toString();
      }
      content = content.replace(/#{DefaultValue}/g, valueStr);
      content = content.replace(/#{Required}/g, "");
    } else {
      content = dartConstructorArgument;
      content = content.replace(/#{Required}/g, this.isFieldRequired(field) ? "required" : "");
    }
    content = content.replace(/#{PropName}/g, field.name);
    return content;
  }
  isFieldRequired(field) {
    return false;
  }
  printDefaultValue(field) {
    if (field.hasDefaultValue && !(field.default instanceof Object)) {
      let defValue = field.default;
      let valueStr;
      if (field.kind === "enum") {
        return `${field.type}.${defValue}`;
      } else {
        return typeof defValue === "string" ? `"${defValue}"` : defValue.toString();
      }
    } else {
      return null;
    }
  }
  generateFromJsonArgument(field) {
    let code;
    if (field.isList) {
      switch (field.kind) {
        case "object":
          code = dartFromJsonModelListArg;
          break;
        case "enum":
          code = dartFromJsonEnumListArg;
          break;
        case "scalar":
          if (field.type === "Int") {
            code = dartFromJsonScalarIntListArg;
          } else if (field.type === "String") {
            code = dartFromJsonScalarStringListArg;
          } else {
            code = dartFromJsonScalarStringListArg;
          }
          break;
        default:
          code = dartFromJsonArg;
          break;
      }
    } else {
      if (field.kind === "enum") {
        code = dartFromJsonEnumArg;
      } else if (field.type === "DateTime") {
        code = dartFromJsonDateTimeArg;
      } else if (field.kind === "object") {
        code = dartFromJsonRefArg;
      } else {
        code = dartFromJsonArg;
      }
    }
    code = this.replacePropName(code, field);
    code = this.replaceNullable(code, field);
    code = this.replaceType(code, field);
    return code;
  }
  generateToJsonKeyVal(field) {
    let content = field.isList && field.kind === "object" ? toJsonListPropertyStub : toJsonPropertyStub;
    content = this.replacePropName(content, field);
    content = this.replaceNullable(content, field);
    return content;
  }
  generatePropertyContent(field) {
    let content = dartPropertyStub;
    content = content.replace(/#{PropName}/g, field.name);
    let dartType = this.getDartType(field);
    let printedType = field.isList ? `List<${dartType}>` : dartType;
    content = content.replace(/#{Type}/g, printedType);
    content = this.replaceNullable(content, field);
    if (this.settings.ModelsImplementBaseClass && field.name === "id") {
      content = "@override\n" + content;
    }
    return content;
  }
  getDartType = (field) => dartTypeMap[field.type] || field.type;
  isProprietaryType = (type) => dartTypeMap[type] == null;
  replaceNullable = (content, field) => content.replace(/#{Nullable}/g, this.isFieldRequired(field) ? "" : "?");
  replacePropName = (content, field) => content.replace(/#{PropName}/g, field.name);
  replaceType = (content, field) => content.replace(/#{Type}/g, this.getDartType(field));
  generateImportStatements() {
    let result = "";
    const checkedTypes = [];
    if (this.settings.ModelsImplementBaseClass) {
      result += `import '${this.settings.ModelsBaseClassFileName}';
`;
    }
    this.model.fields.forEach(({ type }) => {
      if (!checkedTypes.includes(type)) {
        checkedTypes.push(type);
        if (this.isProprietaryType(type)) {
          result += `import '${StringFns.snakeCase(type)}.dart';
`;
        }
      }
    });
    return result;
  }
};

// libs/prisma-generator-dart/src/generators/enum.generators.ts
var generateDartEnum = ({ name, values }, autoGenText) => {
  const enumValues = values.map(({ name: name2 }) => name2).join(",\n	");
  return `${autoGenText}
enum ${name} {
	${enumValues}
}`;
};

// libs/prisma-generator-dart/src/generator.ts
var { version } = require_package();
var defaultOptions = {
  AutoGeneratedWarningText: "//***  AUTO-GENERATED FILE - DO NOT MODIFY ***// ",
  dryRun: false,
  schemaPath: "",
  EnumPath: "enums",
  FormatWithDart: true,
  MakeAllPropsOptional: true,
  ModelsImplementBaseClass: true,
  ModelsBaseClassFileName: "model_base.dart"
};
(0, import_generator_helper.generatorHandler)({
  onManifest() {
    console.log(`${GENERATOR_NAME}:Registered`);
    return {
      version,
      defaultOutput: "../generated",
      prettyName: GENERATOR_NAME
    };
  },
  onGenerate: async (options) => {
    const configOverwrites = {
      schemaPath: options.schemaPath
    };
    const settings = {
      ...defaultOptions,
      ...convertBooleanStrings(options.generator.config),
      ...configOverwrites
    };
    console.log("hello from dart gen");
    const mainGenerator = new MainGenerator(options, settings);
    await mainGenerator.generateFiles();
  }
});
var MainGenerator = class {
  constructor(options, settings) {
    this.options = options;
    this.settings = settings;
    this.writeFile = settings.dryRun ? outputToConsole : writeFileSafely;
    this.outputPath = this.options.generator.output?.value;
  }
  //private dartFiles: string[] = [];
  dartFiles = {};
  writeFile;
  outputPath;
  async generateFiles(options = this.options, settings = this.settings) {
    if (settings.ModelsImplementBaseClass) {
      await this.writeModelBaseFile();
    }
    for (const model of options.dmmf.datamodel.models) {
      console.log(`Processing Model ${model.name}`);
      await this.generateDartModelFile(model);
    }
    for (const tEnum of options.dmmf.datamodel.enums) {
      console.log(`Processing Enum ${tEnum.name}`);
      await this.generateDartEnumFile(tEnum);
    }
    await this.createDartLibraryFile();
    if (this.settings.FormatWithDart) {
      const outputPath = options.generator.output?.value;
      (0, import_child_process.exec)(`dart format "${outputPath}"`, (error, stdout, stderr) => {
        if (error) {
          console.log("dart format couldn't run. Make sure you have Dart installed properly by going to https://dart.dev/get-dart");
          console.log(`error: ${error.message}`);
          return;
        }
        if (stderr) {
          console.log(`stderr: ${stderr}`);
          return;
        }
        console.log(`stdout: ${stdout}`);
      });
    }
  }
  async writeModelBaseFile() {
    const fileName = this.settings.ModelsBaseClassFileName;
    const filePath = import_path.default.join(this.outputPath, fileName);
    const code = dartModelBaseClassStub;
    await this.writeFile(filePath, code);
  }
  async generateDartEnumFile(tEnum) {
    let content = generateDartEnum(tEnum, this.settings.AutoGeneratedWarningText);
    const fileName = `${StringFns.snakeCase(tEnum.name)}.dart`;
    const filePath = import_path.default.join(this.outputPath, fileName);
    console.log(` > Generating enum for Model ${tEnum.name}`);
    await this.writeFile(filePath, content);
    this.dartFiles[tEnum.name] = fileName;
  }
  async createDartLibraryFile() {
    let content = Object.keys(this.dartFiles).reduce((acc, key) => acc + `export '${this.dartFiles[key]}';
`, "");
    const filePath = import_path.default.join(
      this.outputPath,
      `models_library.dart`
    );
    await this.writeFile(filePath, content);
  }
  async generateDartModelFile(model) {
    const dartGenerator = new DartGenerator(this.settings, model);
    const dartContent = dartGenerator.generateContent();
    const fileName = `${StringFns.snakeCase(model.name)}.dart`;
    const filePath = import_path.default.join(
      this.outputPath,
      fileName
    );
    this.dartFiles[model.name] = fileName;
    console.log(` > Generating Dart class for Model ${model.name}`);
    await this.writeFile(filePath, dartContent);
  }
};
